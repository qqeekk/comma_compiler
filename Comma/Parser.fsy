// This is an empty parser. 
%{

%}

%start program

// Token definitions
%token <string> Id
%token <string> LitString
%token <int> LitInt
%token <float> LitFloat
%token <bool> LitBool
%token Plus Minus Asterisk LSlash Eq Greater Less GreaterEq LessEq EqEq BangEq
%token AmpAmp BarBar Bang LParen RParen LBrace RBrace LBrack RBrack Semicolon Colon RArrow Dot Comma 
%token While Do GoTo Break Continue If Else Func Return Var Struct

/* These are artificial */
%token Eof
%token <string> LexFailure 

%type <unit> program

%left Comma
%right Eq
%left BarBar
%left AmpAmp
%left EqEq BangEq
%left Greater GreaterEq Less LessEq
%left Plus Minus
%left Asterisk LSlash 
%right Bang //TODO: add unary plus minus
%left LParen RParen LBrack RBrack Dot

%%
program: 
	| funDecl program                       {()}
    | typeDecl program                      {()}
    |                                       {()}

typeDecl:
    | Struct Id LBrace paramList RBrace {
        ()
    }

funDecl:
    | Func Id LParen paramList RParen RArrow typeId LBrace stmtList RBrace {
        ()
    }

paramList:
    | paramDecl Comma paramList     {()}
    | paramDecl                     {()}
    |                               {()}

paramDecl: 
    | Id Colon typeId               {()}

typeId:
    | Id                            {()}
    | LBrack Id RBrack              {()}

stmtList:
    | stmt stmtList                 {()}
    | stmt                          {()}

stmt:
    | Semicolon                     {()}
    | expr Semicolon                {()}
    | varDecl Semicolon             {()}
    | whileLoop                     {()}
    | ifElse                        {()}
    | Id Colon                      {()}
    | Return expr Semicolon         {()}
    | Break Semicolon               {()}
    | Continue Semicolon            {()}
    | GoTo LitInt                   {()}

varDecl:
    | Var paramDecl Eq expr         {()}

whileLoop:
    | While LParen expr RParen LBrace stmtList RBrace {
        ()
    }

    | Do LBrace stmtList RBrace While LParen expr RParen Semicolon {
        ()
    }

ifElse:
    | If LParen expr RParen LBrace stmtList RBrace Else LBrace stmtList RBrace {
        ()
    }

expr:
    /* literals and constructors */
    | LitInt                        {()}
    | LitFloat                      {()}
    | LitString                     {()}
    | LitBool                       {()}
    | Id                            {()}
    | Id LBrace assocList RBrace    {()}    // type init

    /* unary */
    | expr Dot Id                   {()}
    | expr LBrack expr RBrack       {()}
    | Bang expr                     {()}
    | Plus expr                     {()}
    | Minus expr                    {()}
    | LParen expr RParen            {()}

    | Id LParen exprList RParen     {()}    // funcall
    | expr Eq expr                  {()}    // assign
    | expr Plus expr                {()}
    | expr Minus expr               {()}
    | expr Asterisk expr            {()}
    | expr LSlash expr              {()}
    | expr BarBar expr              {()}
    | expr AmpAmp expr              {()}
    | expr EqEq expr                {()}
    | expr BangEq expr              {()}
    | expr GreaterEq expr           {()}
    | expr Greater expr             {()}
    | expr LessEq expr              {()}
    | expr Less expr                {()}

assocList:
    | assoc Comma assocList         {()}
    | assoc                         {()}
    |                               {()}

assoc:
    | Id Eq expr                    {()}

exprList:
    | expr Comma exprList           {()}
    | expr                          {()}
    |                               {()}

%%