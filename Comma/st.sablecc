Helpers

  sign =
    '+' | '-';

  bit =
    '0' | '1';

  digit =
    '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';

  octal_digit =
    '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7';

  hex_digit =
    '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F';

  unicode_input_character =
    [0..0xffff];

  letter =
    [0x0041..0x005a] |
    [0x0061..0x007a]; // English alphabet

  letter_or_digit =
    letter |
    digit;

  underscored_letter_or_digit =
    ('_')? letter_or_digit;

  common_character_representation =
    [unicode_input_character - ['$' + [''' + '"']]] |
    '$$' |
    '$L' | '$N' | '$P' | '$R' | '$T' |
    '$l' | '$n' | '$p' | '$r' | '$t';

  underscored_digit =
    ('_')? digit;

  integer =
    digit underscored_digit*;

  signed_integer =
    sign? integer;

  underscored_bit =
    ('_')? bit;

  binary_integer =
    '2#' bit underscored_bit*;

  underscored_octal_digit =
    ('_')? octal_digit;

  octal_integer =
    '8#' octal_digit underscored_octal_digit*;

  underscored_hex_digit =
    ('_')? hex_digit;

  hex_integer =
    '16#' hex_digit underscored_hex_digit*;
  
  dollar =
    '$';

  squote =
    ''';

  dquote =
    '"';

  single_byte_character_representation =
    common_character_representation |
    dollar squote |
    dquote |
    dollar hex_digit hex_digit;

  double_byte_character_representation =
    common_character_representation |
    dollar dquote |
    squote |
    dollar hex_digit hex_digit hex_digit hex_digit;


Tokens

  bit =
    bit;

  sign =
    '+' | '-';

  dollar =
    '$';

  hash =
    '#';

  dot =
    '.';

  dash =
    '-';

  underscore =
    '_';

  colon =
    ':';

  semicolon =
    ';';

  colon_eq =
    ':=';

  dot_dot =
    '..';

  comma =
    ',';

  lparen =
    '(';

  rparen =
    ')';

  lbrack =
    '[';

  rbrack =
    ']';

  percent =
    '%';

  or_token =
    'OR';

  xor_token =
    'XOR';

  and_token_full =
    '&' | 'AND';

  eq_token_full =
    '=' | '<>';

  comparison_operator =
    '<' | '>' | '<=' | '>=';

  mul_operator =
    '*' | '/' | 'MOD';

  not_token =
    'NOT';

  power_token =
    '**';

  return_token =
    'RETURN';

  arrow_token =
    '=>';

  // B.1.1 Letters, digits and identifiers

  identifier =
    (letter | '_' letter_or_digit) underscored_letter_or_digit*;

  single_byte_character_string =
    squote single_byte_character_representation* squote;

  double_byte_character_string =
    dquote double_byte_character_representation* dquote;

  // B.1.2.1 Numeric literals

  exponent_sign =
    'E' | 'e';

  signed_integer =
    signed_integer;

  integer =
    integer;

  signed_integer_literal =
    signed_integer |
    binary_integer |
    octal_integer |
    hex_integer;

  unsigned_integer_literal =
    integer |
    binary_integer |
    octal_integer |
    hex_integer;

  string1_type_name =
    'STRING';

  wstring_type_name =
    'WSTRING';

  time_type_name =
    'TIME';

  time_type_name_full =
    'T' | 'TIME';

  signed_integer_type_name =
    'SINT' | 'INT' | 'DINT' | 'LINT';

  unsigned_integer_type_name =
    'USINT' | 'UINT' | 'UDINT' | 'ULINT';

  real_type_name =
    'REAL' | 'LREAL';

  date_type_name =
    'DATE' | 'TIME_OF_DAY' | 'TOD' | 'DATE_AND_TIME' | 'DT';

  bit_string_type_name =
    'BOOL' | 'BYTE' | 'WORD' | 'DWORD' | 'LWORD';

  bit_string_literal_type_name =
    'BYTE' | 'WORD' | 'DWORD' | 'LWORD';

  bool_type_name =
    'BOOL';

  time_of_day_type_name_full =
    'TIME_OF_DAY' | 'TOD';

  date_type_name_full =
    'DATE' | 'D';

  date_and_time_type_name_full =
    'DATE_AND_TIME' | 'DT';

  true_false_literal =
    'TRUE' | 'FALSE';

  day_identifier =
    'd';

  hour_identifier =
    'h';

  minute_identifier =
    'm';

  second_identifier =
    's';

  millisecond_identifier =
    'ms';

  type_token =
    'TYPE';

  end_type_token =
    'END_TYPE';

  array_token =
    'ARRAY';

  of_token =
    'OF';

  struct_token =
    'STRUCT';

  end_struct_token =
    'END_STRUCT';

  var_token =
    'VAR';

  end_var_token =
    'END_VAR';

  constant_token =
    'CONSTANT';

  var_input_token =
    'VAR_INPUT';

  var_output_token =
    'VAR_OUTPUT';

  var_in_out_token =
    'VAR_IN_OUT';

  var_external_token =
    'VAR_EXTERNAL';

  var_temp_token =
    'VAR_TEMP';

  var_access_token =
    'VAR_ACCESS';

  function_token =
    'FUNCTION';

  end_function_token =
    'END_FUNCTION';

  function_block_token =
    'FUNCTION_BLOCK';

  end_function_block_token =
    'END_FUNCTION_BLOCK';

  program_token =
    'PROGRAM';

  end_program_token =
    'END_PROGRAM';

  at_token =
    'AT';

  if_token =
    'IF';

  then_token =
    'THEN';

  end_if_token =
    'END_IF';

  else_if_token =
    'ELSEIF';

  else_token =
    'ELSE';

  case_token =
    'CASE';

  end_case_token =
    'END_CASE';

  for_token =
    'FOR';

  do_token =
    'DO';

  end_for_token =
    'END_FOR';

  to_token =
    'TO';

  by_token =
    'BY';

  while_token =
    'WHILE';

  end_while_token =
    'END_WHILE';

  repeat_token =
    'REPEAT';

  end_repeat_token =
    'END_REPEAT';

  until_token =
    'UNTIL';

  exit_token =
    'EXIT';

  location_prefix =
    'I' | 'Q' | 'M';

  size_prefix =
    'X' | 'B' | 'W' | 'D' | 'L';

  incompl_location =
    'AT' '%' ('I' | 'Q' | 'M') '*';

  edge =
    'R_EDGE' |
    'F_EDGE';

  retain_token =
    'RETAIN';

  non_retain_token =
    'NON_RETAIN';

  retain =
    'RETAIN' |
    'NON_RETAIN';

  standard_function_block_name =
    'SR' | 'RS' | 'R_TRIG' | 'F_TRIG' |
    'CTU' | 'CTD' | 'CTUD' |
    'TP' | 'TON' | 'TOF'; // 2.5.2.3

  direction =
    'READ_WRITE' |
    'READ_ONLY';

Productions

  library =
    library_element_declaration*;

  // B.0

  library_element_declaration =
    {data_type} data_type_declaration |
    {function} function_declaration |
    {function_block} function_block_declaration |
    {program} program_declaration;
    //{configuration} configuration_declaration

  // B.1.2.2 Character strings

  // B.1.3 Data types

  non_generic_type_name =
    {elementary} elementary_type_name |
    {derived} derived_type_name;

  // B.1.3.1 Elementary data types

  elementary_type_name =
    {numeric} numeric_type_name |
    {date} date_type_name |
    {bit_string} bit_string_type_name |
    {string} string1_type_name |
    {wstring} wstring_type_name |
    {time} time_type_name;

  numeric_type_name =
    {integer} integer_type_name |
    {real} real_type_name;

  integer_type_name =
    {signed_integer} signed_integer_type_name |
    {unsigned_integer} unsigned_integer_type_name;

  // B.1.2 Constants

  constant =
    {numeric} numeric_literal |
    {character} character_string |
    {time} time_literal |
    {bit_string} bit_string_literal |
    {boolean} boolean_literal;

  // B.1.2.1 Numeric literals

  numeric_literal =
    {integer} integer_literal |
    {real} real_literal;

  integer_type_name_hashed =
    integer_type_name hash;

  integer_literal =
    integer_type_name_hashed? signed_integer_literal;

  real_type_name_hashed =
    real_type_name hash;

  real_literal =
    real_type_name_hashed? signed_integer dot integer exponent?;

  exponent =
    exponent_sign sign? integer;

  bit_string_literal_type_name_hashed =
    bit_string_literal_type_name hash;

  bit_string_literal =
    bit_string_literal_type_name_hashed?  unsigned_integer_literal;

  bool_type_name_hashed =
    bool_type_name hash;

  boolean_literal =
    {numeric} bool_type_name_hashed? bit |
    {literal} true_false_literal;

  // B.1.2.2 Character strings

  character_string =
    {single} single_byte_character_string |
    {double} double_byte_character_string;

  // B.1.2.3 Time literals

  time_literal =
    {duration} duration |
    {time_of_day} time_of_day |
    {date} date |
    {date_and_time} date_and_time;

  // B.1.2.3.1 Duration

  duration =
    time_type_name_full hash dash? interval;

  interval =
    {days} days |
    {hours} hours |
    {minutes} minutes |
    {seconds} seconds |
    {milliseconds} milliseconds;

  days =
    {decimal} fixed_point day_identifier |
    {hourly} integer day_identifier underscore? hours;

  fixed_point_real_part =
    dot integer;

  fixed_point =
    integer fixed_point_real_part?;

  hours =
    {decimal} fixed_point hour_identifier |
    {minutely} integer hour_identifier underscore? minutes;

  minutes =
    {decimal} fixed_point minute_identifier  |
    {secondly} integer minute_identifier underscore? seconds;

  seconds =
    {decimal} fixed_point second_identifier |
    {millisecondly} integer second_identifier underscore? milliseconds;

  milliseconds =
    fixed_point millisecond_identifier;

  // B.1.2.3.2 Time of day and date

  time_of_day =
    time_of_day_type_name_full hash daytime;

  daytime =
    day_hour [fst]:colon day_minute [snd]:colon day_second;

  day_hour =
    integer;

  day_minute =
    integer;

  day_second =
    fixed_point;

  date =
    date_type_name_full hash date_literal;

  date_literal =
    year [fst]:dash month [snd]:dash day;

  year =
    integer;

  month =
    integer;

  day =
    integer;

  date_and_time =
    date_and_time_type_name_full hash date_literal dash daytime;

  // B.1.3.3 Derived data types

  derived_type_name =
    {single} single_element_type_name |
    {array} array_type_name |
    {struct} structure_type_name |
    {string} string_type_name;

  single_element_type_name =
    {simple} simple_type_name;
    //{subrange} subrange_type_name |
    //{enumerated} enumerated_type_name

  simple_type_name =
    identifier;

  array_type_name =
    identifier;

  structure_type_name =
    identifier;

  string_type_name =
    identifier;

  structure_element_name =
    identifier;

  data_type_declaration_list =
    type_declaration data_type_declaration_list_tail*;

  data_type_declaration_list_tail =
    semicolon type_declaration;

  data_type_declaration =
    type_token data_type_declaration_list end_type_token;

  type_declaration =
    {single_type} single_element_type_declaration |
    {array_type} array_type_declaration |
    {struct_type} structure_type_declaration |
    {string_type} string_type_declaration;

  array_type_declaration =
    array_type_name colon array_spec_init;

  single_element_type_declaration =
    simple_type_declaration;
    //{subrange} subrange_type_declaration |
    //{enumerated} enumerated_type_declaration

  simple_type_declaration =
    simple_type_name colon simple_spec_init;

  simple_spec_initialization =
    colon_eq constant;

  simple_spec_init =
    simple_specification simple_spec_initialization?;

  simple_specification =
    {elementary} elementary_type_name; // |
    //{simple} simple_type_name; // todo: remove

  subrange =
    [fst]:signed_integer dot_dot [snd]:signed_integer;

  subrange_list =
    subrange_list_head* subrange;

  subrange_list_head =
    subrange comma;

  array_spec_initialization =
    colon_eq array_initialization;

  array_spec_init =
    array_specification array_spec_initialization?;

  array_specification =
    //{named} array_type_name | // todo: temporary disabled
    {inline} array_token lbrack subrange_list rbrack of_token non_generic_type_name;

  array_initialization =
    lbrack array_initial_elements_list rbrack;

  array_initial_elements_list =
    array_initial_elements_list_head* array_initial_elements;

  array_initial_elements_list_head =
    array_initial_elements comma;

  array_initial_elements =
    {single} initial_element |
    {repeat} integer lparen initial_element? rparen;

  initial_element =
    {constant} constant |
    //{enumerated} enumerated_value |
    {struct} structure_initialization |
    {array} array_initialization;

  structure_type_declaration =
    structure_type_name colon structure_specification;

  structure_specification =
    {structure_declaration} structure_declaration |
    {initialized} initialized_structure;

  initialized_structure_initialization =
    colon_eq structure_initialization;

  initialized_structure =
    structure_type_name initialized_structure_initialization?;

  structure_declaration =
    struct_token structure_element_declaration_list end_struct_token;

  structure_element_declaration_list =
    structure_element_declaration_list_head* structure_element_declaration;

  structure_element_declaration_list_head =
    structure_element_declaration semicolon;

  structure_element_declaration =
    structure_element_name colon structure_element_init;

  structure_element_init =
    {simple} simple_spec_init |
    //{subrange} subrange_spec_init |
    //{enumerated} enumerated_spec_init |
    {array} array_spec_init |
    {struct} initialized_structure;

  structure_initialization =
    lparen structure_element_initialization_list rparen;

  structure_element_initialization_list =
    structure_element_initialization_list_head* structure_element_initialization;

  structure_element_initialization_list_head =
    structure_element_initialization comma;

  structure_element_initialization =
    structure_element_name colon_eq initial_element;

  string_wstring_type_name =
    {string} string1_type_name |
    {wstring} wstring_type_name;

  string_type_declaration_len_spec =
    lbrack [len]:integer rbrack;

  string_type_declaration_initialization =
    colon_eq [val]:character_string;

  string_type_declaration =
    // string_type_name colon string_wstring_type_name string_type_declaration_len_spec? string_type_declaration_initialization?;
    {len} string_type_name colon string_wstring_type_name string_type_declaration_len_spec string_type_declaration_initialization? |
    {len_spec} string_type_name colon string_wstring_type_name string_type_declaration_initialization;

  // B.1.4 Variables

  variable =
    {direct_variable} direct_variable |
    {symbolic_variable} symbolic_variable;

  variable_complex =
    {direct_variable} direct_variable |
    {symbolic_variable} symbolic_variable_complex;

  symbolic_variable =
    {variable} variable_name |
    {array} symbolic_variable subscript_list |
    {struct} symbolic_variable dot field_selector;

  symbolic_variable_complex =
    {array} symbolic_variable subscript_list |
    {struct} symbolic_variable dot field_selector;

  variable_name =
    identifier;

  // B.1.4.1 Directly represented variables

  direct_variable =
    percent location_prefix size_prefix? integer prefixed_integer*;

  prefixed_integer =
    dot integer;

  // B.1.4.2 Multi-element variables

  subscript_list =
    subscript_list_head* subscript;

  subscript_list_head =
    subscript comma;

  subscript =
    expression;

  field_selector =
    identifier;

  // B.1.4.3 Declaration and initialization

  input_declarations =
    var_input_token retain input_declaration_list end_var_token;

  input_declaration_list =
    input_declaration_list_head* input_declaration;

  input_declaration_list_head =
    input_declaration semicolon;

  input_declaration =
    {var} var_init_decl |
    {edge} edge_declaration;

  edge_declaration =
    var1_list colon bool_type_name edge;

  var_init_decl =
    {var} var1_init_decl |
    {array_var} array_var_init_decl |
    {struct} structured_var_init_decl |
    {fb_name} fb_name_decl |
    {string} string_var_declaration;

  var1_init_decl =
    var1_list colon var1_spec_init;

  var1_list =
    var1_list_head* variable_name;

  var1_list_head =
    variable_name comma;

  var1_spec_init =
    {simple} simple_spec_init;
    //{subrange} subrange_spec_init |
    //{enumerated} enumerated_spec_init

  array_var_init_decl =
    var1_list colon array_spec_init;

  structured_var_init_decl =
    var1_list colon initialized_structure;

  fb_name_decl_initialization =
    colon_eq structure_initialization;

  fb_name_decl =
    fb_name_list colon function_block_type_name fb_name_decl_initialization?;

  fb_name_list =
    fb_name_list_head* fb_name;

  fb_name_list_head =
    fb_name comma;

  fb_name =
    identifier;

  output_declarations =
    var_output_token retain var_init_decl_list end_var_token;

  var_init_decl_list =
    var_init_decl_list_head* var_init_decl;

  var_init_decl_list_head =
    var_init_decl semicolon;

  input_output_declarations =
    var_in_out_token var_declaration_list end_var_token;

  var_declaration_list =
    var_declaration_list_head* var_declaration;

  var_declaration_list_head =
    var_declaration semicolon;

  var_declaration =
    {temp} temp_var_decl |
    {fb_name} fb_name_decl;

  temp_var_decl =
    {var} var1_declaration |
    {array} array_var_declaration |
    {struct} structured_var_declaration |
    {string} string_var_declaration;

  var1_declaration =
    var1_list colon var1_declaration_specification;

  var1_declaration_specification =
    simple_specification;
    //subrange_specification |
    //enumerated_specification;

  array_var_declaration =
    var1_list colon array_specification;

  structured_var_declaration =
    var1_list colon structure_type_name;

  var_declarations =
    var_token constant_token? var_init_decl_list end_var_token;

  retentive_var_declarations =
    var_token retain_token var_init_decl_list end_var_token;

  constant_token_or_retain =
    {constant} constant_token |
    {retain} retain;

  located_var_declarations =
    var_token constant_token_or_retain? located_var_decl_list end_var_token;

  located_var_decl_list =
    located_var_decl_list_head* located_var_decl;

  located_var_decl_list_head =
    located_var_decl semicolon;

  located_var_decl =
    variable_name? location colon located_var_spec_init;

  external_var_declarations =
    var_external_token constant_token? external_declaration_list end_var_token;

  external_declaration_list =
    external_declaration_list_head* external_declaration;

  external_declaration_list_head =
    external_declaration semicolon;

  external_declaration =
    global_var_name colon external_declaration_specification;

  external_declaration_specification =
    {simple} simple_specification |
    //{subrange} subrange_specification |
    //enumerated_specification |
    {array} array_specification |
    {struct} structure_type_name |
    {fb} function_block_type_name;

  global_var_name =
    identifier;

  located_var_spec_init =
    {simple} simple_spec_init |
    //subrange_spec_init |
    //enumerated_spec_init |
    {array} array_spec_init |
    {struct} initialized_structure |
    {sstring} single_byte_string_spec |
    {dstring} double_byte_string_spec;

  location =
    at_token direct_variable;

  string_var_declaration =
    {single} single_byte_string_var_declaration |
    {double} double_byte_string_var_declaration;

  single_byte_string_var_declaration =
    var1_list colon single_byte_string_spec;

  brack_integer =
    lbrack integer rbrack;

  single_byte_string_spec_initialization =
    colon_eq single_byte_character_string;

  single_byte_string_spec =
    string1_type_name brack_integer? single_byte_string_spec_initialization?;

  double_byte_string_var_declaration =
    var1_list colon double_byte_string_spec;

  double_byte_string_spec_initialization =
    colon_eq double_byte_character_string;

  double_byte_string_spec =
    wstring_type_name brack_integer? double_byte_string_spec_initialization?;

  incompl_located_var_declarations =
    var_token retain incompl_located_var_decl_list end_var_token;

  incompl_located_var_decl_list =
    incompl_located_var_decl_list_head* incompl_located_var_decl;

  incompl_located_var_decl_list_head =
    incompl_located_var_decl semicolon;

  incompl_located_var_decl =
    variable_name incompl_location colon var_spec;

  var_spec =
    {simple} simple_specification |
    //subrange_specification |
    //enumerated_specification |
    {array} array_specification |
    {struct} structure_type_name |
    {string} string1_type_name brack_integer? |
    {wstring} wstring_type_name brack_integer?;

  // B.1.5 Program organization units

  // B.1.5.1 Functions

  function_name =
    identifier; // custom + 2.5.1.5

  function_declaration =
    function_token function_name colon return_type_name function_var_declaration* function_body end_function_token;

  return_type_name =
    {elementary} elementary_type_name |
    {derived} derived_type_name;

  function_var_declaration =
    {io} io_var_declarations |
    {function} function_var_decls;

  io_var_declarations =
    {input} input_declarations |
    {ouput} output_declarations |
    {io} input_output_declarations;

  function_var_decls =
    var_token constant_token? var2_init_decl_list end_var_token;

  function_body =
    //ladder_diagram |
    //function_block_diagram |
    //instruction_list |
    statement_list;
    //<other languages>

  var2_init_decl_list =
    var2_init_decl_list_head* var2_init_decl;

  var2_init_decl_list_head =
    var2_init_decl semicolon;

  var2_init_decl =
    {var1} var1_init_decl |
    {array} array_var_init_decl |
    {struct} structured_var_init_decl |
    {string} string_var_declaration;

  // B.1.5.2 Function blocks

  function_block_type_name =
    {standard} standard_function_block_name |
    {derived} derived_function_block_name;

  derived_function_block_name =
    identifier;

  function_block_declaration =
    function_block_token derived_function_block_name function_block_var_declarations* function_block_body end_function_block_token;

  function_block_var_declarations =
    {io} io_var_declarations |
    {other} other_var_declarations;

  other_var_declarations =
    {external} external_var_declarations |
    {var} var_declarations |
    {retentive} retentive_var_declarations |
    {non_retentive} non_retentive_var_declarations |
    {temp} temp_var_decls |
    {incompl} incompl_located_var_declarations;

  temp_var_decls =
    var_temp_token temp_var_decl_list end_var_token;

  temp_var_decl_list =
    temp_var_decl_list_head* temp_var_decl;

  temp_var_decl_list_head =
    temp_var_decl semicolon;

  non_retentive_var_declarations =
    var_token non_retain_token var_init_decl_list end_var_token;

  function_block_body =
    statement_list;
    // other langs;

  // B.1.5.3 Programs

  program_type_name =
    identifier;

  access_name =
    identifier;

  program_declaration =
    program_token program_type_name program_var_declarations* function_block_body end_program_token;

  program_var_declarations =
    {io} io_var_declarations |
    {other} other_var_declarations |
    {located} located_var_declarations |
    {access} program_access_decls;

  program_access_decls =
    var_access_token program_access_decl_list end_var_token;

  program_access_decl_list =
    program_access_decl_list_head* program_access_decl;

  program_access_decl_list_head =
    program_access_decl semicolon;

  program_access_decl =
    access_name [fst]:colon symbolic_variable [snd]:colon non_generic_type_name direction?;

  // B.3 Language ST (Structured Text)

  // B.3.1 Expressions

  expression =
    {or} expression or_token xor_expression |
    {unary_expression} xor_expression;

  xor_expression =
    {xor} xor_expression xor_token and_expression |
    {unary} and_expression;

  and_expression =
    {and} and_expression and_token_full comparison |
    {unary} comparison;

  comparison =
    {comparison} comparison eq_token_full equ_expression |
    {unary} equ_expression;

  equ_expression =
    {equ} equ_expression comparison_operator add_expression |
    {unary} add_expression;

  add_expression =
    {add} add_expression add_operator term |
    {unary} term;

  add_operator =
    sign;

  term =
    {mul} term mul_operator power_expression |
    {term} power_expression;

  power_expression =
    {power} power_expression power_token unary_expression |
    {unary} unary_expression;

  unary_expression =
    unary_operator* primary_expression;

  unary_operator =
    {dash} dash |
    {not} not_token;

  primary_expression =
    {constant} constant |
    //enumerated_value |
    {variable} variable |
    {paren} lparen expression rparen |
    {call} function_name lparen param_assignment_list rparen;

  param_assignment_list =
    param_assignment_list_head* param_assignment;

  param_assignment_list_head =
    param_assignment comma;

  // B.3.2 Statements

  statement_list =
    statement_list_head+;

  statement_list_head =
    statement? semicolon;

  // First two result in shift-reduce
  statement =
    {assign} variable_name colon_eq expression |
    {call} fb_name lparen param_assignment_list? rparen |
    {assign2} variable_complex colon_eq expression |
    {return} return_token |
    {selection} selection_statement |
    {iter} iteration_statement;


  // B.3.2.2 Subprogram control statements

  param_assignment_lvalue =
    variable_name colon_eq;

  param_assignment =
    {expr} param_assignment_lvalue? expression |
    {arrow} not_token? variable_name arrow_token variable;

  // B.3.2.3 Selection statements

  selection_statement =
    {if} if_statement |
    {case} case_statement;

  if_statement =
    if_token expression then_token statement_list elseif_statement* else_statement* end_if_token;

  elseif_statement =
    else_if_token expression then_token statement_list;

  else_statement =
    else_token statement_list;

  case_statement_else_clause =
    else_token statement_list;

  case_statement =
    case_token expression of_token case_element+ case_statement_else_clause? end_case_token;

  case_element =
    case_list colon statement_list;

  case_list =
    case_list_head* case_list_element;

  case_list_head =
    case_list_element comma;

  case_list_element =
    {subrange} subrange |
    {integer} signed_integer;
    //enumerated_value;

  // B.3.2.4 Iteration statements

  iteration_statement =
    {for} for_statement |
    {while} while_statement |
    {repeat} repeat_statement |
    {exit} exit_statement;

  for_statement =
    for_token control_variable colon_eq for_list do_token statement_list end_for_token;

  control_variable =
    identifier;

  for_list_by_clause =
    by_token [by]:expression;

  for_list =
    [from]:expression to_token [to]:expression for_list_by_clause?;

  while_statement =
    while_token expression do_token statement_list end_while_token;

  repeat_statement =
    repeat_token statement_list until_token expression end_repeat_token;

  exit_statement =
    exit_token;
