Helpers

  unicode_input_character =
    [0..0xffff];

  common_character_representation =
    [unicode_input_character - ['$' + [''' + '"']]] |
    '$$' |
    '$L' | '$N' | '$P' | '$R' | '$T' |
    '$l' | '$n' | '$p' | '$r' | '$t';

Tokens

  squote =
    ''';
  
  dquote =
    '"';

  dollar =
    '$';

  hash =
    '#';

  dot =
    '.';

  dash =
    '-';

  underscore =
    '_';

  colon =
    ':';

  semicolon =
    ';';

  colon_eq =
    ':=';

  dot_dot =
    '..';

  comma =
    ',';

  lparen =
    '(';
  
  rparen =
    ')';

  lbrack =
    '[';

  rbrack =
    ']';

  // B.1.1 Letters, digits and identifiers

  letter =
    [0x0041..0x005a] |
    [0x0061..0x007a]; // English alphabet

  digit =
    '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';

  octal_digit =
    '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7';

  hex_digit =
    '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F';

  identifier =
    (letter | '_' letter_or_digit) underscored_letter_or_digit*;

  letter_or_digit =
    letter |
    digit;

  underscored_letter_or_digit =
    ('_')? letter_or_digit;

  // B.1.2.1 Numeric literals

  sign =
    '+' | '-';

  exponent_sign =
    'E' | 'e';

  bit =
    '0' | '1';

  signed_integer_literal =
    signed_integer |
    binary_integer |
    octal_integer |
    hex_integer;

  unsigned_integer_literal =
    integer |
    binary_integer |
    octal_integer |
    hex_integer;

  signed_integer =
    sign? integer;

  integer =
    digit underscored_digit*;

  underscored_digit =
    ('_')? digit;

  binary_integer =
    '2#' bit underscored_bit*;

  underscored_bit =
    ('_')? bit;

  octal_integer =
    '8#' octal_digit underscored_octal_digit*;

  underscored_octal_digit =
    ('_')? octal_digit;

  hex_integer =
    '16#' hex_digit underscored_hex_digit*;

  underscored_hex_digit =
    ('_')? hex_digit;

  string1_type_name =
    'STRING';

  wstring_type_name =
    'WSTRING';

  time_type_name =
    'TIME';

  time_type_name_full =
    'T' | time_type_name;

  signed_integer_type_name =
    'SINT' | 'INT' | 'DINT' | 'LINT';

  unsigned_integer_type_name =
    'USINT' | 'UINT' | 'UDINT' | 'ULINT';

  real_type_name =
    'REAL' | 'LREAL';

  date_type_name =
    'DATE' | 'TIME_OF_DAY' | 'TOD' | 'DATE_AND_TIME' | 'DT';

  bit_string_type_name =
    'BOOL' | 'BYTE' | 'WORD' | 'DWORD' | 'LWORD';

  bit_string_literal_type_name =
    'BYTE' | 'WORD' | 'DWORD' | 'LWORD';

  bool_type_name =
    'BOOL';

  time_of_day_type_name_full =
    'TIME_OF_DAY' | 'TOD';

  date_type_name_full =
    'DATE' | 'D';

  date_and_time_type_name_full =
    'DATE_AND_TIME' | 'DT';

  true_false_literal =
    'TRUE' | 'FALSE';

  day_identifier =
    'd';

  hour_identifier =
    'h';

  minute_identifier =
    'm';
  
  second_identifier =
    's';

  millisecond_identifier =
    'ms';

  type_token =
    'TYPE';

  end_type_token =
    'END_TYPE';

  array_token =
    'ARRAY';

  of_token =
    'OF';

  struct_token =
    'STRUCT';

  end_struct_token =
    'END_STRUCT';

  var_token =
    'VAR';

  end_var_token =
    'END_VAR';

Productions

  library =
    library_element_declaration*;

  // B.0

  library_element_declaration =
    {data_type} data_type_declaration |
    {function} function_declaration |
    {function_block} function_block_declaration |
    {program} program_declaration;
    //{configuration} configuration_declaration

  // B.1.2.2 Character strings

  single_byte_character_string =
    squote single_byte_character_representation* squote;

  double_byte_character_string =
    dquote double_byte_character_representation* dquote;

  single_byte_character_representation =
    {common} common_character_representation |
    {escaped} dollar squote |
    {quote} dquote |
    {code} dollar [fst]:hex_digit [snd]:hex_digit;

  double_byte_character_representation =
    {common} common_character_representation |
    {escaped} dollar dquote |
    {quote} squote |
    {code} dollar [fst]:hex_digit [snd]:hex_digit [trd]:hex_digit [fth]:hex_digit;


  // B.1.3 Data types

  non_generic_type_name =
    elementary_type_name |
    derived_type_name;

  // B.1.3.1 Elementary data types

  elementary_type_name =
    {numeric} numeric_type_name |
    {date} date_type_name |
    {bit_string} bit_string_type_name |
    {string} string1_type_name |
    {wstring} wstring_type_name |
    {time} time_type_name;

  numeric_type_name =
    {integer} integer_type_name |
    {real} real_type_name;

  integer_type_name =
    {signed_integer} signed_integer_type_name |
    {unsigned_integer} unsigned_integer_type_name;

  // B.1.2 Constants

  constant =
    {numeric} numeric_literal |
    {character} character_string |
    {time} time_literal |
    {bit_string} bit_string_literal |
    {boolean} boolean_literal;

  // B.1.2.1 Numeric literals

  numeric_literal =
    {integer} integer_literal |
    {real} real_literal;

  integer_literal =
     (integer_type_name hash)? signed_integer_literal;

  real_literal =
    (real_type_name hash)? signed_integer dot integer exponent?;

  exponent =
    exponent_sign sign? integer;

  bit_string_literal =
    (bit_string_literal_type_name hash)?  unsigned_integer_literal;

  boolean_literal =
    {numeric} (bool_type_name hash)? bit |
    {literal} true_false_literal;

  // B.1.2.2 Character strings

  character_string =
    {single} single_byte_character_string |
    {double} double_byte_character_string;

  // B.1.2.3 Time literals

  time_literal =
    {duration} duration |
    {time_of_day} time_of_day |
    {date} date |
    {date_and_time} date_and_time;

  // B.1.2.3.1 Duration

  duration =
    time_type_name_full hash dash? interval;

  interval =
    days |
    hours |
    minutes |
    seconds |
    milliseconds;

  days =
    fixed_point day_identifier |
    integer day_identifier underscore? hours;

  fixed_point =
    integer (dot [real]:integer)?;

  hours =
    fixed_point hour_identifier |
    integer hour_identifier underscore? minutes;

  minutes =
    fixed_point minute_identifier  |
    integer minute_identifier underscore? seconds;

  seconds =
    fixed_point second_identifier |
    integer second_identifier underscore? milliseconds;

  milliseconds =
    fixed_point millisecond_identifier;

  // B.1.2.3.2 Time of day and date

  time_of_day =
    time_of_day_type_name_full hash daytime;

  daytime =
    day_hour colon day_minute colon day_second;

  day_hour =
    integer;

  day_minute =
    integer;

  day_second =
    fixed_point;

  date =
    date_type_name_full hash date_literal;

  date_literal =
    year dash month dash day;

  year =
    integer;

  month =
    integer;

  day =
    integer;

  date_and_time =
    date_and_time_type_name_full hash date_literal dash daytime;

  // B.1.3.3 Derived data types

  derived_type_name =
    {single} single_element_type_name |
    {array} array_type_name |
    {struct} structure_type_name |
    {string} string_type_name;

  single_element_type_name =
    {simple} simple_type_name;
    //{subrange} subrange_type_name |
    //{enumerated} enumerated_type_name

  simple_type_name =
    identifier;

  array_type_name =
    identifier;

  structure_type_name =
    identifier;

  string_type_name =
    identifier;

  structure_element_name =
    identifier;

  data_type_declaration_list =
    data_type_declaration_list_head* type_declaration;

  data_type_declaration_list_head =
    type_declaration semicolon;

  data_type_declaration =
    type_token data_type_declaration_list end_type_token;

  type_declaration =
    {single} single_element_type_declaration |
    {array} array_type_declaration |
    {struct} structure_type_declaration |
    {string} string_type_declaration;

  single_element_type_declaration =
    simple_type_declaration;
    //{subrange} subrange_type_declaration |
    //{enumerated} enumerated_type_declaration

  simple_type_declaration =
    simple_type_name colon simple_spec_init;

  simple_spec_init =
    simple_specification colon_eq constant?;

  simple_specification =
    {elementary} elementary_type_name |
    {simple} simple_type_name;

  subrange =
    signed_integer dot_dot signed_integer;

  subrange_list =
    subrange_list_head* subrange;

  subrange_list_head =
    subrange comma;

  array_type_declaration =
    array_type_name colon array_spec_init;

  array_spec_init =
    array_specification (colon_eq array_initialization);

  array_specification =
    {named} array_type_name |
    {inline} array_token lbrack subrange_list rbrack of_token non_generic_type_name;

  array_initialization =
    lbrack array_initial_elements_list rbrack;

  array_initial_elements_list =
    array_initial_elements_list_head* array_initial_elements;

  array_initial_elements_list_head =
    array_initial_elements comma;

  array_initial_elements =
    {single} initial_element |
    {repeat} integer lparen initial_element? rparen;

  initial_element =
    {constant} constant |
    //{enumerated} enumerated_value |
    {struct} structure_initialization |
    {array} array_initialization;

  structure_type_declaration =
    structure_type_name colon structure_specification;

  structure_specification =
    {structure_declaration} structure_declaration |
    {initialized} initialized_structure;

  initialized_structure =
    structure_type_name (colon_eq structure_initialization)?;

  structure_declaration =
    struct_token structure_element_declaration_list end_struct_token;

  structure_element_declaration_list =
    structure_element_declaration_list_head* structure_element_declaration;

  structure_element_declaration_list_head =
    structure_element_declaration semicolon;

  structure_element_declaration =
    structure_element_name colon structure_element_init;

  structure_element_init =
    {simple} simple_spec_init |
    //{subrange} subrange_spec_init |
    //{enumerated} enumerated_spec_init |
    {array} array_spec_init |
    {struct} initialized_structure;

  structure_initialization =
    lparen structure_element_initialization_list rparen;

  structure_element_initialization_list =
    structure_element_initialization_list_head* structure_element_initialization;

  structure_element_initialization_list_head =
    structure_element_initialization comma;

  structure_element_initialization =
    structure_element_name colon_eq initial_element;

  string_type_declaration =
    string_type_name colon (string1_type_name | wstring_type_name) (lbrack [len]:integer rbrack)? (colon_eq [val]:character_string)?;

  // B.1.4 Variables

  variable =
    direct_variable |
    symbolic_variable;

  symbolic_variable =
    variable_name |
    multi_element_variable;

  variable_name =
    identifier;

  // B.1.4.1 Directly represented variables

  direct_variable =
    '%' location_prefix size_prefix? integer prefixed_integer*;

  prefixed_integer =
    dot integer;

  location_prefix =
    'I' | 'Q' | 'M';

  size_prefix =
    'X' | 'B' | 'W' | 'D' | 'L';

  // B.1.4.2 Multi-element variables

  multi_element_variable =
    array_variable |
    structured_variable;

  array_variable =
    subscripted_variable subscript_list;

  subscripted_variable =
    symbolic_variable;

  subscript_list =
    subscript_list_head* subscript;

  subscript_list_head =
    subscript comma;

  subscript =
    expression;

  structured_variable =
    record_variable dot field_selector;

  record_variable =
    symbolic_variable;

  field_selector =
    identifier;

  // B.1.4.3 Declaration and initialization

  input_declarations =
    'VAR_INPUT' retain input_declaration_list end_var_token;

  input_declaration_list =
    input_declaration_list_head* input_declaration;

  input_declaration_list_head =
    input_declaration semicolon;

  input_declaration =
    {var} var_init_decl |
    {edge} edge_declaration;

  edge_declaration =
    var1_list colon bool_type_name edge;

  edge =
    'R_EDGE' |
    'F_EDGE';

  var_init_decl =
    {var} var1_init_decl |
    {array} array_var_init_decl |
    {struct} structured_var_init_decl |
    {fb_name} fb_name_decl |
    {string} string_var_declaration;

  var1_init_decl =
    var1_list colon var1_spec_init;

  var1_list =
    var1_list_head* variable_name;

  var1_list_head =
    variable_name comma;

  var1_spec_init =
    {simple} simple_spec_init;
    //{subrange} subrange_spec_init |
    //{enumerated} enumerated_spec_init

  array_var_init_decl =
    var1_list colon array_spec_init;

  structured_var_init_decl =
    var1_list colon initialized_structure;

  fb_name_decl =
    fb_name_list colon function_block_type_name (colon_eq structure_initialization)?;

  fb_name_list =
    fb_name_list_head* fb_name;

  fb_name_list_head =
    fb_name comma;

  fb_name =
    identifier;

  output_declarations =
    'VAR_OUTPUT' retain var_init_decl_list end_var_token;

  retain =
    'RETAIN' |
    'NON_RETAIN';

  var_init_decl_list =
    var_init_decl_list_head* var_init_decl;

  var_init_decl_list_head =
    var_init_decl semicolon;

  input_output_declarations =
    'VAR_IN_OUT' var_declaration_list end_var_token;

  var_declaration_list =
    var_declaration_list_head* var_declaration;

  var2_init_decl_list_head =
    var_declaration semicolon;

  var_declaration =
    temp_var_decl |
    fb_name_decl;

  temp_var_decl =
    var1_declaration |
    array_var_declaration |
    structured_var_declaration |
    string_var_declaration;

  var1_declaration =
    var1_list colon var1_declaration_specification;

  var1_declaration_specification =
    simple_specification;
    //subrange_specification |
    //enumerated_specification;

  array_var_declaration =
    var1_list colon array_specification;

  structured_var_declaration =
    var1_list colon structure_type_name;

  var_declarations =
    var_token ('CONSTANT')? var_init_decl_list end_var_token;

  retentive_var_declarations =
    var_token 'RETAIN' var_init_decl_list end_var_token;

  located_var_declarations =
    var_token ('CONSTANT' | 'RETAIN' | 'NON_RETAIN')? located_var_decl_list end_var_token;

  located_var_decl_list =
    located_var_decl_list_head* located_var_decl;

  located_var_decl_list_head =
    located_var_decl semicolon;

  located_var_decl =
    variable_name? location colon located_var_spec_init;

  external_var_declarations =
    'VAR_EXTERNAL' ('CONSTANT')? external_declaration_list end_var_token;

  external_declaration_list =
    external_declaration_list_head* external_declaration;

  external_declaration_list_head =
    external_declaration semicolon;

  external_declaration =
    global_var_name colon external_declaration_specification;

  external_declaration_specification =
    simple_specification |
    subrange_specification |
    enumerated_specification |
    array_specification |
    structure_type_name |
    function_block_type_name;

  global_var_name =
    identifier;

  located_var_spec_init =
    simple_spec_init |
    //subrange_spec_init |
    //enumerated_spec_init |
    array_spec_init |
    initialized_structure |
    single_byte_string_spec |
    double_byte_string_spec;

  location =
    'AT' direct_variable;

  string_var_declaration =
    {single} single_byte_string_var_declaration |
    {double} double_byte_string_var_declaration;

  single_byte_string_var_declaration =
    var1_list colon single_byte_string_spec;

  single_byte_string_spec =
    string1_type_name (lbrack integer rbrack)? (colon_eq single_byte_character_string)?;

  double_byte_string_var_declaration =
    var1_list colon double_byte_string_spec;

  double_byte_string_spec ::=
    wstring_type_name (lbrack integer rbrack)? (colon_eq double_byte_character_string)?;

  incompl_located_var_declarations =
    var_token retain incompl_located_var_decl_list end_var_token;

  incompl_located_var_decl_list =
    incompl_located_var_decl_list_head* incompl_located_var_decl;

  incompl_located_var_decl_list_head =
    incompl_located_var_decl semicolon;

  incompl_located_var_decl =
    variable_name incompl_location colon var_spec;

  incompl_location =
    'AT' '%' ('I' | 'Q' | 'M') '*';

  var_spec =
    simple_specification |
    //subrange_specification |
    //enumerated_specification |
    array_specification |
    structure_type_name |
    string1_type_name (lbrack integer rbrack)? |
    wstring_type_name (lbrack integer rbrack)?;

  // B.1.5 Program organization units

  // B.1.5.1 Functions

  function_name =
    identifier; // custom + 2.5.1.5

  function_declaration =
    'FUNCTION' function_name colon return_type_name function_var_declaration* function_body 'END_FUNCTION';

  return_type_name =
    {elementary} elementary_type_name |
    {derived} derived_type_name;

  function_var_declaration =
    {io} io_var_declarations |
    {function} function_var_decls;

  io_var_declarations =
    {input} input_declarations |
    {ouput} output_declarations |
    {io} input_output_declarations;

  function_var_decls =
    var_token ('CONSTANT')? var2_init_decl_list end_var_token;

  function_body =
    //ladder_diagram |
    //function_block_diagram |
    //instruction_list |
    statement_list;
    //<other languages>

  var2_init_decl_list =
    var2_init_decl_list_head* var2_init_decl;

  var2_init_decl_list_head =
    var2_init_decl semicolon;

  var2_init_decl =
    {var1} var1_init_decl |
    {array} array_var_init_decl |
    {struct} structured_var_init_decl |
    {string} string_var_declaration;

  // B.1.5.2 Function blocks

  function_block_type_name =
    {standard} standard_function_block_name |
    {derived} derived_function_block_name;

  standard_function_block_name =
    'SR' | 'RS' | 'R_TRIG' | 'F_TRIG' |
    'CTU' | 'CTD' | 'CTUD' |
    'TP' | 'TON' | 'TOF'; // 2.5.2.3

  derived_function_block_name =
    identifier;

  function_block_declaration =
    'FUNCTION_BLOCK' derived_function_block_name function_block_var_declarations* function_block_body 'END_FUNCTION_BLOCK';

  function_block_var_declarations =
    {io} io_var_declarations |
    {other} other_var_declarations;

  other_var_declarations =
    {external} external_var_declarations |
    {var} var_declarations |
    {retentive} retentive_var_declarations |
    {non_retentive} non_retentive_var_declarations |
    {temp} temp_var_decls |
    {incompl} incompl_located_var_declarations;

  temp_var_decls =
    'VAR_TEMP' temp_var_decl_list end_var_token;

  temp_var_decl_list =
    temp_var_decl_list_head* temp_var_decl;

  temp_var_decl_list_head =
    temp_var_decl semicolon;

  non_retentive_var_declarations =
    var_token 'NON_RETAIN' var_init_decl_list end_var_token;

  function_block_body =
    statement_list;
    // other langs;

  // B.1.5.3 Programs

  program_type_name =
    identifier;

  access_name =
    identifier;

  direction =
    'READ_WRITE' |
    'READ_ONLY';

  program_declaration =
    'PROGRAM' program_type_name program_var_declarations* function_block_body 'END_PROGRAM';

  program_var_declarations =
    io_var_declarations |
    other_var_declarations |
    located_var_declarations |
    program_access_decls;

  program_access_decls =
    'VAR_ACCESS' program_access_decl_list end_var_token;

  program_access_decl_list =
    program_access_decl_list_head* program_access_decl;

  program_access_decl_list_head =
    program_access_decl semicolon;

  program_access_decl =
    access_name colon symbolic_variable colon non_generic_type_name direction?;

  // B.3 Language ST (Structured Text)

  // B.3.1 Expressions

  expression =
    xor_expression expression_or_clause*;

  expression_or_clause =
    'OR' xor_expression;

  xor_expression =
    and_expression expression_xor_clause*;

  expression_xor_clause =
    'XOR' and_expression;

  and_expression =
    comparison expression_and_clause*;

  expression_and_clause =
    ('&' | 'AND') comparison;

  comparison =
    equ_expression expression_ne_clause*;

  expression_ne_clause =
    ('=' | '<>') equ_expression;

  equ_expression =
    add_expression expression_comparison_operator_clause*;

  expression_comparison_operator_clause =
    comparison_operator add_expression;

  comparison_operator =
    '<' | '>' | '<=' | '>=';

  add_expression =
    term expression_add_operator_clause*;

  expression_add_operator_clause =
    add_operator term;

  add_operator =
    sign;

  term =
    power_expression expression_mul_operator_clause*;

  expression_mul_operator_clause =
    mul_operator power_expression;

  mul_operator =
    '*' | '/' | 'MOD';

  power_expression =
    unary_expression expression_power_clause*;

  expression_power_clause =
    '**' unary_expression;

  unary_expression =
    unary_operator* primary_expression;

  unary_operator =
    dash | 'NOT';

  primary_expression =
    constant |
    //enumerated_value |
    variable |
    lparen expression rparen |
    function_name lparen param_assignment_list rparen;

  param_assignment_list =
    param_assignment_list_head* param_assignment;

  param_assignment_list_head =
    param_assignment comma;

  // B.3.2 Statements

  statement_list =
    statement_list_head+;

  statement_list_head =
    statement? semicolon;

  statement =
    assignment_statement |
    subprogram_control_statement |
    selection_statement |
    iteration_statement;

  // B.3.2.1 Assignment statements

  assignment_statement =
    variable colon_eq expression;

  // B.3.2.2 Subprogram control statements

  subprogram_control_statement =
    fb_invocation |
    'RETURN';

  fb_invocation =
    fb_name lparen param_assignment_list? rparen;

  param_assignment =
    (variable_name colon_eq)? expression |
    ('NOT')? variable_name '=>' variable;

  // B.3.2.3 Selection statements

  selection_statement =
    if_statement |
    case_statement;

  if_statement
    'IF' expression 'THEN' statement_list elseif_statement* else_statement* 'END_IF';

  elseif_statement =
    'ELSEIF' expression 'THEN' statement_list;

  else_statement =
    'ELSE' statement_list;

  case_statement =
    'CASE' expression 'OF' case_element+ ('ELSE' statement_list)? 'END_CASE';

  case_element =
    case_list colon statement_list;

  case_list =
    case_list_head* case_list_element;

  case_list_head =
    case_list_element comma;

  case_list_element =
    subrange |
    signed_integer;
    //enumerated_value;

  // B.3.2.4 Iteration statements

  iteration_statement =
    for_statement |
    while_statement |
    repeat_statement |
    exit_statement;

  for_statement =
    'FOR' control_variable colon_eq for_list 'DO' statement_list 'END_FOR';

  control_variable =
    identifier;

  for_list =
    [from]:expression 'TO' [to]:expression ('BY' [by]:expression)?;

  while_statement =
    'WHILE' expression 'DO' statement_list 'END_WHILE';

  repeat_statement =
    'REPEAT' statement_list 'UNTIL' expression 'END_REPEAT';

  exit_statement =
    'EXIT';
