{
module Lexer

open System
open System.Text
open Microsoft.FSharp.Text.Lexing
open Comma.Errors
open Comma.ErrorLogger
open Parser

let spos (lexbuf: LexBuffer<_>) = lexbuf.StartPos
let epos (lexbuf: LexBuffer<_>) = lexbuf.EndPos
let lexeme (lexbuf:LexBuffer<_>) = Encoding.UTF8.GetString(lexbuf.Lexeme)
let setNextLine (lexbuf:LexBuffer<_>) = lexbuf.EndPos <- lexbuf.EndPos.NextLine

let tryInt32 lexeme =
    try Ok (LitInt (int lexeme))
    with _ -> Error integerOverflow

let tryFloat lexeme =
    try Ok (LitFloat (float lexeme))
    with _ -> Error invalidFloat
}

let digit = ['0'-'9']
let integer = '0'|['1'-'9']digit*
let alpha = ['a'-'z' 'A'-'Z']
let whitespace = [' ' '\t']
let newline = ('\n' | '\r' '\n')
let scientific = ['e''E']['+''-']? digit+
let fixed = '.' digit+
let float = integer (fixed | scientific | fixed scientific)
let id = ['_']* alpha (alpha | digit | '_')*

rule tokenize = parse
| "//"                      { singleLineComment lexbuf }	
| newline                   { setNextLine lexbuf; tokenize lexbuf }
| whitespace                { tokenize lexbuf }
| '"'                       { singleLineString (epos lexbuf) (new StringBuilder()) lexbuf }
| integer					{ tryInt32 (lexeme lexbuf) }
| float                     { tryFloat (lexeme lexbuf) }
| "true"                    { Ok (LitBool true) }
| "false"                   { Ok (LitBool false) }
| '+'                       { Ok Plus }
| '-'                       { Ok Minus }
| '*'                       { Ok Asterisk }
| '/'                       { Ok LSlash }
| '='                       { Ok Eq }
| '>'                       { Ok Greater }
| '<'                       { Ok Less }
| ">="                      { Ok GreaterEq }
| "<="                      { Ok LessEq }
| "=="                      { Ok EqEq }
| "!="                      { Ok BangEq }
| "&&"                      { Ok AmpAmp }
| "||"                      { Ok BarBar }
| '!'                       { Ok Bang }
| '('                       { Ok LParen }
| ')'                       { Ok RParen }
| '{'                       { Ok LBrace }
| '}'                       { Ok RBrace }
| '['                       { Ok LBrack }
| ']'                       { Ok RBrack }
| ';'                       { Ok Semicolon }
| ':'                       { Ok Colon }
| "->"                      { Ok RArrow }
| '.'                       { Ok Dot }
| ','                       { Ok Comma }
| "while"                   { Ok While }
| "do"                      { Ok Do }
| "goto"                    { Ok GoTo }
| "break"                   { Ok Break }
| "continue"                { Ok Continue }
| "if"                      { Ok If }
| "else"                    { Ok Else }
| "func"                    { Ok Func }
| "return"                  { Ok Return }
| "var"                     { Ok Var }
| "struct"                  { Ok Struct }
| id                        { Ok (Id (lexeme lexbuf)) }
| eof                       { Ok Eof }
| _                         { Error unknownIdentifier }

and singleLineComment = parse
| newline                   { setNextLine lexbuf; tokenize lexbuf }
| eof                       { Ok Eof }
| _	                        { singleLineComment lexbuf }

and singleLineString pos state = parse
| '"'                       { lexbuf.StartPos <- pos; Ok (LitString (string state)) }
| newline                   { setNextLine lexbuf; Error unmatchedDoubleQuote }
| eof                       { Error unmatchedDoubleQuote }
| _                         { singleLineString pos (state.Append (lexeme lexbuf)) lexbuf }

{
let rec getToken (logger: Logger) (lexbuf: LexBuffer<_>) =
    let lex = tokenize lexbuf

    let pos = let ep = epos lexbuf in ep.Line + 1, ep.Column    
    let logToken tok  =  info logger (sprintf "%A: %A" pos tok)
    let logError text = error logger (sprintf "%A: %s" pos text)
    
    match lex with
    | Ok tok     -> logToken tok; tok
    | Error text -> 
        logError text 
        match lexbuf.IsPastEndOfStream with
        | false -> getToken logger lexbuf
        | true  -> logToken Eof; Eof
}